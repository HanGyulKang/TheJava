병렬 처리를 위해 Stream을 사용하는 경우,  
**ArrayList**와 **LinkedList** 중 **ArrayList**가 더 효과적인 자료구조이다.

### 데이터 접근 속도

---

* **ArrayList**  
  * 내부적으로 배열을 사용하기 때문에 인덱스 접근이 O(1)로 매우 빠름  
  * 병렬 처리를 할 때, 각 스레드가 리스트의 서로 다른 부분을 처리하게 되는데, ArrayList는 인덱스를 통해 빠르게 접근할 수 있어 병렬 처리를 더 효과적으로 수행할 수 있음.
* **LinkedList** 
  * 요소 접근 시 인덱스를 사용할 수 있지만, 인덱스 접근이 O(n) 시간이 걸림.
  * 이는 LinkedList가 요소들을 연결 리스트로 관리하기 때문임.
  * 따라서, 병렬 처리 시 접근 속도가 느려져 성능이 저하될 수 있음.

 
### 병렬 스트림의 분할 가능성

---
* **ArrayList**
  * 배열 기반 자료구조이므로 데이터를 쉽게 균등하게 나눌 수 있음. 
  * 병렬 스트림을 사용하면 ArrayList는 내부적으로 데이터를 쉽게 분할하여 여러 스레드에서 병렬로 처리할 수 있음. 
  * Spliterator가 효율적으로 작동하여 병렬 처리를 위한 데이터 분할이 용이함.
* **LinkedList** 
  * LinkedList는 분할하기가 어렵고, 요소에 접근할 때도 시간이 더 걸리기 때문에 병렬 스트림을 사용할 때 성능이 떨어짐. 
  * 특히 데이터가 크고 복잡할수록 병렬 처리의 효율이 떨어질 수 있음.


### 캐싱 및 예측 메모리 접근:

---

* **ArrayList** 
  * 메모리 상에서 연속된 공간에 저장되어 있어 CPU 캐시 효율이 높음. 
  * 병렬 처리에서 캐시 효율성이 높으면 성능 향상에 기여함.
* **LinkedList** 
  * 요소들이 메모리상에서 불연속적으로 존재하기 때문에 캐시 미스(cache miss)가 더 자주 발생
  * 병렬 처리 시 성능이 저하될 가능성이 큽니다.
    
### 결론

---

병렬 스트림을 사용할 때는 **ArrayList가 LinkedList보다 훨씬 더 좋은 선택**!   
ArrayList의 인덱스 기반 접근 속도와 데이터 분할의 용이성 덕분에 병렬 처리의 성능이 더 뛰어나기 때문임.  
LinkedList는 요소를 자주 추가하거나 삭제하는 작업이 많을 때 유리하지만, 병렬 처리에서는 오히려 성능이 저하될 수 있음.